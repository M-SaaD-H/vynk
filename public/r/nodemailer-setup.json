{
  "name": "nodemailer-setup",
  "title": "Advanced Nodemailer Setup",
  "description": "Advanced Nodemailer Setup with rate limiting and retries accessibility",
  "type": "registry:snippet",
  "files": [
    {
      "path": "registry/backend-snippets/src/utils/nodemailer.ts",
      "type": "registry:snippet",
      "target": "src/utils",
      "content": "import nodemailer from \"nodemailer\"\nimport { google } from \"googleapis\"\n\n// Type definitions\ninterface EmailServiceConfig {\n  clientId?: string;\n  clientSecret?: string;\n  redirectURI?: string;\n  refreshToken?: string;\n  sendersAddress?: string;\n  organizationName?: string;\n  minDelay?: number;\n  maxRetries?: number;\n  retryDelay?: number;\n}\n\ninterface EmailOptions {\n  to: string | string[];\n  cc?: string | string[];\n  bcc?: string | string[];\n  subject: string;\n  html?: string;\n  text?: string;\n  content?: string; // Backward compatibility\n  attachments?: Array<{\n    filename?: string;\n    content?: string | Buffer;\n    path?: string;\n    contentType?: string;\n  }>;\n  headers?: Record<string, string>;\n  priority?: \"High\" | \"Normal\" | \"Low\";\n  trackingId?: string;\n}\n\ninterface EmailResult {\n  success: boolean;\n  messageId?: string;\n  accepted?: string[];\n  rejected?: string[];\n  response?: string;\n  error?: string;\n}\n\nclass EmailService {\n  private clientId;\n  private clientSecret;\n  private redirectURI;\n  private refreshToken;\n  private sendersAddress;\n  private organizationName;\n  private oauth2Client: any;\n  private lastEmailTime: number = 0;\n  private minDelay: number;\n  private maxRetries: number;\n  private retryDelay: number;\n\n  constructor(config: EmailServiceConfig = {}) {\n    this.clientId = config.clientId || process.env.CLIENT_ID || \"\";\n    this.clientSecret = config.clientSecret || process.env.CLIENT_SECRET || \"\";\n    this.redirectURI = config.redirectURI || process.env.REDIRECT_URI || \"\";\n    this.refreshToken = config.refreshToken || process.env.REFRESH_TOKEN || \"\";\n    this.sendersAddress = config.sendersAddress || process.env.SENDERS_ADDRESS || \"\";\n    this.organizationName = config.organizationName || process.env.ORGANIZATION_NAME || \"Vynk\"; // or hard code here\n\n    // Configuration\n    this.minDelay = config.minDelay || 100;\n    this.maxRetries = config.maxRetries || 3;\n    this.retryDelay = config.retryDelay || 1000;\n\n    // Validate required environment variables\n    this.validateConfig();\n\n    // Initialize OAuth2 client\n    this.oauth2Client = new google.auth.OAuth2(\n      this.clientId,\n      this.clientSecret,\n      this.redirectURI\n    );\n\n    this.oauth2Client.setCredentials({ refresh_token: this.refreshToken });\n  }\n\n  private validateConfig(): void {\n    const requiredVars = [\n      { key: \"clientId\", name: \"CLIENT_ID\" },\n      { key: \"clientSecret\", name: \"CLIENT_SECRET\" },\n      { key: \"redirectURI\", name: \"REDIRECT_URI\" },\n      { key: \"refreshToken\", name: \"REFRESH_TOKEN\" },\n      { key: \"sendersAddress\", name: \"SENDERS_ADDRESS\" }\n    ];\n\n    const missingVars = requiredVars.filter(({ key }) => !this[key as keyof this]);\n\n    if (missingVars.length > 0) {\n      throw new Error(`Missing required configuration: ${missingVars.map(v => v.name).join(\", \")}`);\n    }\n  }\n\n  private async createTransport(): Promise<nodemailer.Transporter> {\n    try {\n      const accessToken = await this.oauth2Client.getAccessToken();\n\n      if (!accessToken.token) {\n        throw new Error(\"Failed to obtain access token\");\n      }\n\n      return nodemailer.createTransport({\n        service: \"gmail\",\n        auth: {\n          type: \"OAuth2\",\n          user: this.sendersAddress,\n          clientId: this.clientId,\n          clientSecret: this.clientSecret,\n          refreshToken: this.refreshToken,\n          accessToken: accessToken.token\n        },\n        // Connection pooling for better performance\n        pool: true,\n        maxConnections: 5,\n        maxMessages: 100\n      });\n    } catch (error) {\n      console.error(\"Error creating email transporter:\", error);\n      throw new Error(`Failed to create email transporter: ${(error as Error).message}`);\n    }\n  }\n\n  private async rateLimitCheck(): Promise<void> {\n    const now = Date.now();\n    const timeSinceLastEmail = now - this.lastEmailTime;\n\n    if (timeSinceLastEmail < this.minDelay) {\n      const waitTime = this.minDelay - timeSinceLastEmail;\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n\n    this.lastEmailTime = Date.now();\n  }\n\n  // Use this function to send Emails\n  async sendEmail(options: EmailOptions, retryCount: number = 0): Promise<EmailResult> {\n    try {\n      // Validate required options\n      if (!options.to || !options.subject) {\n        throw new Error(\"Missing required email options: to, subject\");\n      }\n\n      // Rate limiting\n      await this.rateLimitCheck();\n\n      const transporter = await this.createTransport();\n\n      const mailOptions: nodemailer.SendMailOptions = {\n        from: `${this.organizationName} <${this.sendersAddress}>`,\n        to: options.to,\n        subject: options.subject,\n        html: options.html || options.content,\n        text: options.text,\n        cc: options.cc,\n        bcc: options.bcc,\n        attachments: options.attachments,\n        headers: {\n          \"X-Priority\": options.priority || \"Normal\",\n          \"X-Mailer\": \"EmailService-v2.0\",\n          ...options.headers\n        }\n      };\n\n      // Add custom message ID for tracking\n      if (options.trackingId) {\n        mailOptions.headers = {\n          ...mailOptions.headers,\n          \"X-Tracking-ID\": options.trackingId\n        };\n      }\n\n      const result = await transporter.sendMail(mailOptions);\n\n      console.log(`‚úÖ Email sent successfully to ${options.to} - Message ID: ${result.messageId}`);\n\n      return {\n        success: true,\n        messageId: result.messageId,\n        accepted: result.accepted,\n        rejected: result.rejected,\n        response: result.response\n      };\n\n    } catch (error) {\n      const errorMessage = (error as Error).message;\n      console.error(`‚ùå Error sending email to ${options.to}:`, errorMessage);\n\n      if (retryCount < this.maxRetries) {\n        console.log(`üîÑ Retrying email send (${retryCount + 1}/${this.maxRetries})...`);\n        await new Promise(resolve => setTimeout(resolve, this.retryDelay * Math.pow(2, retryCount)));\n        return this.sendEmail(options, retryCount + 1);\n      }\n\n      return {\n        success: false,\n        error: `Failed to send email after ${this.maxRetries} attempts: ${errorMessage}`\n      };\n    }\n  }\n\n  // Create your email templates here as a function which callls the above \"sendEmail\" function or use React Email Templates\n}\n\n// Create singleton instance\nconst emailService = new EmailService();\n\n// Export both the class and instance\nexport { EmailService, emailService };\n\n// Export types\nexport type { EmailOptions, EmailResult };"
    }
  ],
  "dependencies": [
    "nodemailer",
    "googleapis"
  ],
  "devDependencies": [
    "@types/nodemailer"
  ]
}